## Check MSSC Hierarhical Bayesian Model

## Instead of using SymSim to simulate the dataset
## Here we firstly use the data simulated from our model.
## Hyper parameters are learned from the real dataset: PBMC.

## * set R environment
source("hbnb_set_r_lib_env_01.R")

hbnbm <- modules::import("hbnb_mssc_03")

options("import.path" = here("rutils"))
myt <- modules::import("transform")
myfit <- modules::import("myfitdistr")
mypseudo <- modules::import("pseudobulk")
mypbmc <- modules::import("pbmc")

## * load pbmc demo data and vifit.
refdir <- here::here("src", "modelcheck", "01_hbnb_share_vcond_share_vmu")
demo_pbmc <- readRDS(file.path(refdir, "snb_pool_ref_pbmc.rds"))
demo_vifit <- readRDS(file.path(refdir, "est_hbnb_params_ref_pbmc.rds"))

## * functions
simulate_mu_and_r <- function(ngene = 40, mu, r) {
  ## mu: n by g matrix from vifit draw
  ## r: n by g matrix from vifit draw

  ## simulate mu and r: g by 2 matrix

  cols <- sample(seq_len(ncol(mu)),
    size = ngene,
    replace = T
  )
  invisible(t(vapply(seq_len(ngene), function(i) {
    col <- cols[i]
    c(
      ## sample(mu[, col], size = 1),
      ## sample(r[, col], size = 1)
      mean(mu[, col]),
      min(10.0, median(r[, col]))
    )
  }, FUN.VALUE = c(0.0, 0.0))))
}

simulate_muind <- function(tnind = 10, ngene = 40, muind) {
  ## tnind: total number of individual in the dataset
  ## muind: n by g by tnind from vifit draw

  ## simulate muind: ngene by tnind

  gcols <- sample(seq_len(dim(muind)[2]),
    size = ngene,
    replace = T
  )
  invisible(t(vapply(gcols, FUN = function(g) {
    icols <- sample(seq_len(dim(muind)[3]),
      size = tnind,
      replace = T
    )
    invisible(vapply(icols, FUN = function(i) {
      ## sample(muind[, g, i], size = 1)
      mean(muind[, g, i])
    }, FUN.VALUE = 0.0))
  }, FUN.VALUE = rep(0.0, tnind))))
}

simulate_mucond <- function(ngene = 40, ncond = 2, mu_cond,
                            sd_noise = 0.05) {
  ## mu_cond: n by g by ncond (2)

  ## simulate mu_cond: ngene by ncond
  ndiff <- ngene / 2
  gcols <- sample(seq_len(dim(mu_cond)[2]),
    size = ndiff,
    replace = T
  )
  diff <- t(vapply(gcols, function(g) {
    row <- sample(dim(mu_cond)[1], size = 1)
    invisible(mu_cond[row, g, ])
  }, FUN.VALUE = c(0.0, 0.0)))

  undiff <- t(vapply(seq_len(ngene - ndiff), FUN = function(i) {
    invisible(rnorm(ncond, mean = 0.0, sd = sd_noise))
  }, FUN.VALUE = c(0.0, 0.0)))

  invisible(rbind(diff, undiff))
}

simulate_params <- function(nind = 5, ngene = 200, params_vifit) {
  ## simulate parameters based on previous fitted posterior distribution
  ## based on variational inference

  ncond <- 2
  mur <- simulate_mu_and_r(ngene,
    mu = params_vifit$mu,
    r = params_vifit$nb_r
  )
  mu_ind <- simulate_muind(nind * ncond,
    ngene = ngene,
    params_vifit$mu_ind
  )
  mu_cond <- simulate_mucond(
    ngene = ngene, ncond = ncond,
    mu_cond = params_vifit$mu_cond,
    sd_noise = 0.05
  )
  params <- list(
    mu = mur[, 1], r = mur[, 2],
    mu_ind = mu_ind, mu_cond = mu_cond
  )
}

simulate_data <- function(nind = 5, ncell = 100, ngene = 40,
                          s, params) {
  ## params are generated by simulate_params
  ## nind is per condition
  ## ncell is per individual
  ## ncond equals to 2

  ncond <- 2
  n <- nind * ncell * ncond
  s <- sample(s, size = n, replace = T)
  logs <- log(s)
  cond <- rep(seq_len(ncond), each = nind * ncell)
  ind <- rep(seq_len(ncond * nind), each = ncell)

  c2y <- vapply(seq_len(ngene), function(g) {
    loglambda <- logs + params$mu[g] +
      params$mu_cond[g, cond] + params$mu_ind[g, ind]
    invisible(rnbinom(n = n, mu = exp(loglambda), size = params$r[g]))
  }, FUN.VALUE = rep(0.0, n))
  data <- list(s = s, cond = cond, ind = ind, y2c = t(c2y))
  return(invisible(list(params = params, data = data)))
}

## run hbnb
get_vifit <- function(hbnbsim, calibrate_with_opt = FALSE) {
  ind <- hbnbsim$data$ind
  cond <- hbnbsim$data$cond
  s <- hbnbsim$data$s
  y2c <- hbnbsim$data$y2c
  hi_params <- hbnbm$set_hi_params(
    k = max(ind),
    j = max(cond),
    g = nrow(y2c),
    cnt = y2c,
    s = s,
    cond = cond, ind = ind,
    scale = 1.96^2
  )
  data <- hbnbm$to_hbnb_data(y2c, ind, cond, s, hi_params$hp)
  if (calibrate_with_opt) {
    ip <- hbnbm$calibrate_init_params(hi_params$ip, data = data)
  } else {
    ip <- hi_params$ip
  }
  vifit <- hbnbm$run_hbnb_vi(data = data, ip = ip)
  est_params <- lapply(hbnbm$nm_params, function(nm) {
    hbnbm$extract_vifit(vifit, data, nm)
  })
  names(est_params) <- hbnbm$nm_params
  return(invisible(list(
    vifit = vifit, data = data,
    ip = ip, hip = hi_params,
    est_params = est_params
  )))
}


## run pseudobulk
get_auc_pseudobulk <- function(hbnbsim) {
  y2c <- hbnbsim$data$y2c
  ind <- hbnbsim$data$ind
  cond <- hbnbsim$data$cond
  ngene <- nrow(y2c)
  ndiff <- ngene / 2
  diffg <- seq_len(ndiff)
  ndiffg <- (ndiff + 1):ngene
  pseudo_analysis <- mypseudo$pseudobulk_deseq2(
    cnt_gbc = y2c,
    mybatches = ind,
    myconds = factor(cond)
  )
  if (!is.null(rownames(y2c))) {
    rownames(pseudo_analysis) <- rownames(y2c)
  }
  auc <- mypseudo$calc_auc(
    deseq2_res = pseudo_analysis,
    degs = diffg, ndegs = ndiffg, scorecol = "pvalue"
  )
  return(invisible(auc))
}

## auc from hbnb
get_auc_hbnb <- function(hbnb_vifit, hbnbsim, epsilon = 0.1) {
  mu_cond <- hbnb_vifit$est_params$mu_cond
  rank_stats <- hbnbm$get_rank_statistics(mu_cond,
    c1 = 1, c2 = 2,
    epsilon = epsilon
  )
  ngene <- nrow(hbnbsim$data$y2c)
  ndiff <- ngene / 2
  diffg <- seq_len(ndiff)
  ndiffg <- (ndiff + 1):ngene
  auc <- hbnbm$get_auc(rank_stats, diffg, ndiffg)
  return(invisible(c(auc, rank_stats)))
}

## check the estimation and the ground truth

mssc_boxplot <- function(mat, vec, main,
                         sub = NULL, xlab = "Gene Index",
                         ylab = NULL) {
  boxplot(mat, use.cols = TRUE)
  abline(h = 0, col = "blue", lty = 3, lwd = 3)
  points(x = seq_len(length(vec)), y = vec, pch = 19, col = "red")
  title(
    main = main, sub = sub, xlab = xlab, ylab = ylab,
    cex.lab = 1.2, cex.sub = 1.3, cex.main = 1.5
  )
}

plot_eval_mucond <- function(hbnb_vifit, hbnbsim,
                             f = colMeans,
                             c1 = 1, c2 = 2,
                             main = "Differential Expression Level",
                             sub = NULL, ylab = NULL) {
  ## gt_mucond: ground truth, g by ncond (2)
  ## est_mucond: n by g by ncond
  delta <- function(gene_index) {
    delta_gt <- gt_mucond[gene_index, c1] - gt_mucond[gene_index, c2]
    delta_est <- as.matrix(est_mucond[, gene_index, c1] -
      est_mucond[, gene_index, c2])
    return(invisible(delta_est - t(replicate(nsample, delta_gt))))
  }

  gt_mucond <- hbnbsim$params$mu_cond
  est_mucond <- hbnb_vifit$est_params$mu_cond
  ngene <- dim(est_mucond)[2]
  nsample <- dim(est_mucond)[1]
  ndiff <- ngene / 2
  allg <- seq_len(ngene)
  diffg <- seq_len(ndiff)
  ndiffg <- (ndiff + 1):ngene

  est_diff <- as.matrix(est_mucond[, diffg, c1] - est_mucond[, diffg, c2])
  gt_diff_level <- hbnbsim$params$mu_cond[diffg, 1] -
    hbnbsim$params$mu_cond[diffg, 2]

  mssc_boxplot(
    mat = est_diff,
    vec = gt_diff_level,
    main = main, sub = sub, ylab = ylab
  )

  return(invisible(list(
    ddiff = f(delta(diffg)), dndiff = f(delta(ndiffg)),
    dall = f(delta(allg)), dmat = delta(allg), est_diff = est_diff
  )))
}


plot_mu <- function(hbnb_vifit, hbnbsim, param = "mu",
                    gene_index,
                    f = colMeans,
                    main = "Average Expression Level",
                    sub = NULL, ylab = NULL) {
  ## gt: g
  gt <- hbnbsim$params[[param]][gene_index]
  ## est: n by g
  est <- as.matrix(hbnb_vifit$est_params[[param]][, gene_index])
  mssc_boxplot(
    mat = est, vec = gt, main = main,
    sub = sub, ylab = ylab
  )
}

plot_r <- function(hbnb_vifit, hbnbsim,
                   gene_index,
                   f = colMeans,
                   main = "Dispersion",
                   ylab = NULL, sub = NULL) {
  ## gt: vector, length of ngene
  gt <- hbnbsim$params[["r"]][gene_index]
  ## est: n by g
  est <- as.matrix(hbnb_vifit$est_params[["nb_r"]][, gene_index])
  mssc_boxplot(mat = est, vec = gt,
               main = main, ylab = ylab, sub = sub)
}

plot_avg_muind <- function(hbnb_vifit, hbnbsim, f = colMeans,
                           gene_index = diffg,
                           main = "Individual Effect Level",
                           sub = NULL, ylab = NULL) {
  ## gt: ngene by nind
  gt <- hbnbsim$params$mu_ind[gene_index, ]
  ## est: nsample by ngene by nind
  est <- hbnb_vifit$est_params$mu_ind[, gene_index, ]

  mean_gt <- rowMeans(gt)
  mean_est <- t(vapply(
    1:dim(est)[1],
    function(i) {
      rowMeans(est[i, , ])
    },
    rowMeans(est[1, , ])
  ))

  mssc_boxplot(
    mat = mean_est, vec = mean_gt, main = main,
    sub = sub, ylab = ylab
  )
}

## * main
main <- function(nind = 5,
                 ncells = c(10, 20, 40, 80, 100, 200),
                 ngene = 40, ncond = 2) {
  ## simulate the params
  sim_params <- simulate_params(nind, ngene, demo_vifit)

  auc <- matrix(NA, nrow = 3, ncol = length(ncells))
  colnames(auc) <- ncells
  rownames(auc) <- c("pseudobulk", "mssc_z", "mssc_p")
  pdf(
    file = stringr::str_glue(
      "hbnb_share_r_vcond_{nind}ind_{ngene}gene.pdf"
    ),
    width = 15, height = 10
  )


  for (i in seq_len(length(ncells))) {
    ncell <- ncells[i]
    ## fix params, simulate the data
    hbnbsim <- simulate_data(
      nind = nind, ncell = ncell, ngene = ngene,
      s = demo_pbmc$s, params = sim_params
    )

    hbnb_vifit <- get_vifit(hbnbsim)
    ## save intermidiate result
    saveRDS(
      object = list(hbnb_vifit = hbnb_vifit, hbnbsim = hbnbsim),
      file = str_glue("hbnb_vifit_{nind}ind_{ncell}cell_{ngene}gene.rds")
    )

    ## compare with pseudobulk
    auc[1, i] <- get_auc_pseudobulk(hbnbsim)$auc
    tmp <- get_auc_hbnb(hbnb_vifit, hbnbsim, epsilon = 0.1)
    auc[2, i] <- tmp$auc_z[1,1]
    auc[3, i] <- tmp$auc_p[1,1]

    ## compare with the simulated params
    ## main <- "MSSC hiearchical Bayesian model under variational inference"
    ## one page
    plot_eval_mucond(hbnb_vifit,
                     hbnbsim,
                     main = str_glue("Differential Expression Level [{ncell} Cells]"))
    ## second page
    par(mfrow = c(2, 1))
    plot_mu(hbnb_vifit, hbnbsim, param = "mu",
            gene_index = seq_len(ngene / 2),
            main = "Average Expression Level")
    plot_eval_mucond(hbnb_vifit, hbnbsim,
      main = "Differential Expression Level"
      )
    par(mfrow = c(2, 1))
    plot_avg_muind(hbnb_vifit, hbnbsim,
                   gene_index = seq_len(ngene / 2))
    plot_r(hbnb_vifit, hbnbsim, gene_index = seq_len(ngene / 2),
           main = "Dispersion")
  }
  dev.off()
  saveRDS(
    object = auc,
    file = stringr::str_glue("hbnb_auc_{nind}ind_{ngene}gene.rds")
  )
}

main()
